trigger:
  - '*'
  
pool:
  vmImage: ubuntu-latest

variables:
  buildConfiguration: 'Release'
  # dockerRegistryServiceConnection: 'NexosRegistry'
  # imageRepository: 'test'
  # containerRegistry: 'nexos.azurecr.io'
  # dockerfilePath: '$(Build.SourcesDirectory)/Tailspin.SpaceGame.Web/Dockerfile'
  # tag: '$(Build.BuildId)'

  dockerRegistryServiceConnection: 'DockerHub'
  imageRepository: 'edissonpena/nexos'
  dockerfilePath: '$(Build.SourcesDirectory)/Tailspin.SpaceGame.Web/Dockerfile'
  tag: '$(Build.BuildId)'

steps:

- checkout: self
  fetchDepth: 0

- task: UseDotNet@2
  displayName: 'Use .NET SDK 6.x'
  inputs:
    packageType: sdk
    version: '6.x'

- task: DotNetCoreCLI@2
  displayName: 'Restore project dependencies'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- task: SonarCloudPrepare@1
  inputs:
    sonarCloud: 'SonarCloud'
    organization: 'edissonpena'
    scannerMode: 'MSBuild'
    projectKey: 'EdissonPena_Nexos'

- task: DotNetCoreCLI@2
  displayName: 'Build the project - Release'
  inputs:
    command: 'build'
    arguments: '--no-restore --configuration Release'
    projects: '**/*.csproj'

- task: SonarCloudAnalyze@1

- task: SonarCloudPublish@1
  displayName: 'Code Analysis - Publish QG'
  inputs:
    pollingTimeoutSec: '300'

- task: DotNetCoreCLI@2
  displayName: 'Run unit tests - $(buildConfiguration)'
  inputs:
    command: 'test'
    arguments: '--no-build --configuration $(buildConfiguration)'
    publishTestResults: true
    projects: '**/*.Tests.csproj'

# - task: SonarQubePrepare@5
#   inputs:
#     SonarQube: # string. Required. SonarQube Server Endpoint. 
#     scannerMode: 'MSBuild'
#     #configMode: 'file' # 'file' | 'manual'. Required when scannerMode = CLI. Mode. Default: file.
#     #configFile: 'sonar-project.properties' # string. Optional. Use when scannerMode = CLI && configMode = file. Settings File. Default: sonar-project.properties.
#     #cliProjectKey: # string. Required when scannerMode = CLI && configMode = manual. Project Key. 
#     projectKey: 'nexos_test'


# - task: DotNetCoreCLI@2
#   displayName: 'Publish the project - Release'
#   inputs:
#     command: 'publish'
#     projects: '**/*.csproj'
#     publishWebProjects: false
#     arguments: '--no-build --configuration Release --output $(Build.ArtifactStagingDirectory)/Release'
#     zipAfterPublish: true

# - publish: '$(Build.ArtifactStagingDirectory)'
#   artifact: drop

# - download: current
#   artifact: drop

- task: Docker@2
  displayName: Build and push an image to container registry
  inputs:
    command: buildAndPush
    repository: $(imageRepository)
    dockerfile: $(dockerfilePath)
    containerRegistry: $(dockerRegistryServiceConnection)
    tags: |
      latest
      $(tag)
  
# - task: AzureWebApp@1
#   displayName: 'Azure App Service Deploy: website'
#   inputs:
#     azureSubscription: 'Azure'
#     appName: 'nexos'
#     package: '$(Pipeline.Workspace)/drop/$(buildConfiguration)/*.zip'

# - task: AzureWebAppContainer@1
#   displayName: 'Deploy the container'
#   inputs:
#     azureSubscription: 'NexosApp'
#     appName: 'nexosapp'
#     imageName: 'nexos.azurecr.io/test:latest'

- task: AzureWebAppContainer@1
  displayName: 'Deploy the container'
  inputs:
    azureSubscription: 'NexosTest'
    appName: 'nexostest'
    imageName: 'edissonpena/nexos:latest'

- script: |
    wget -c https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.6.3.tgz
    tar -xf apache-jmeter-5.6.3.tgz
  displayName: 'Install the dependency packages'

- script: |
        apache-jmeter-5.6.3/bin/./jmeter -Jjmeter.reportgenerator.overall_granularity=1000 -n -t test.jmx -l results/results.jtl -j results/output.log -e -o report
  displayName: 'Run JMeter'

- script: |
    JMETER_RESULTS=results/results.jtl
    JUNIT_RESULTS=output.xml
    python3 jtl_junit_converter.py $JMETER_RESULTS $JUNIT_RESULTS
  displayName: 'RESULTS: Convert JMeter Results to JUnit Format'

- task: PublishTestResults@2
  inputs:
    testResultsFormat: 'JUnit'
    testResultsFiles: 'output.xml'
    failTaskOnFailedTests: true
  displayName: 'RESULTS: Publish Load Testing Results'

# - task: PublishTestResults@2
#   displayName: 'Publish Load Test Results'
#   inputs:
#     testResultsFormat: 'JUnit'
#     testResultsFiles: '$(Build.SourcesDirectory)/TestFiles/LoadReports/Junit.xml'
#     failTaskOnFailedTests: false

- publish: $(System.DefaultWorkingDirectory)/results
  artifact: jmeter-results
  condition: succeededOrFailed()
  displayName: 'RESULTS: Publish Load Test Artifacts'

- task: PublishPipelineArtifact@1
  displayName: 'Publish JMeter HTML Report'
  inputs:
    targetPath: report
    artifact: jmeter-report

#   - task: PublishBuildArtifacts@1
#     displayName: "Publish load test Artifacts"
#     inputs:
#      pathToPublish: '$(Build.SourcesDirectory)/TestFiles/LoadReports/'
#     condition: always()

- task: publishhtmlreport@1
  inputs:
    htmlType: 'Jmeter'
    JmeterReportsPath: '$(Build.SourcesDirectory)/results'